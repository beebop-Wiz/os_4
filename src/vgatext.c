#include "vgatext.h"
#include "vga.h"
#include "port.h"
#include "vt100_state.h"

const unsigned int console_colors[16] = { // Solarized
  0x073642, // 0 base02
  0xdc322f, // 1 red
  0x859900, // 2 green
  0xb58900, // 3 yellow
  0x268bd2, // 4 blue
  0xd33682, // 5 magenta
  0x2aa198, // 6 cyan
  0xeee8d5, // 7 base2
  0x002b36, // 8 base03
  0xcb4b16, // 9 orange
  0x586e75, // 10 base01
  0x657b83, // 11 base00
  0x839496, // 12 base0
  0x6c71c4, // 13 violet
  0x93a1a1, // 14 base1
  0xfdf6e3, // 15 base3
};

unsigned char vt100[15][256] = VT100_state;

unsigned char font8x8_basic[256][8] = {
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+0000 (nul)
    { 0x7e, 0x81, 0xa5, 0x81, 0xbd, 0x99, 0x81, 0x7e},   // U+0001
    { 0x7e, 0xff, 0xdb, 0xff, 0xc3, 0xe7, 0xff, 0x7e},   // U+0002
    { 0x00, 0x36, 0x7f, 0x7f, 0x7f, 0x3e, 0x1c, 0x08},   // U+0003
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+0004
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+0005
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+0006
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+0007
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+0008
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+0009
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+000A
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+000B
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+000C
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+000D
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+000E
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+000F
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+0010
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+0011
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+0012
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+0013
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+0014
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+0015
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+0016
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+0017
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+0018
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+0019
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+001A
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+001B
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+001C
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+001D
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+001E
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+001F
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+0020 (space)
    { 0x18, 0x3C, 0x3C, 0x18, 0x18, 0x00, 0x18, 0x00},   // U+0021 (!)
    { 0x36, 0x36, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+0022 (")
    { 0x36, 0x36, 0x7F, 0x36, 0x7F, 0x36, 0x36, 0x00},   // U+0023 (#)
    { 0x0C, 0x3E, 0x03, 0x1E, 0x30, 0x1F, 0x0C, 0x00},   // U+0024 ($)
    { 0x00, 0x63, 0x33, 0x18, 0x0C, 0x66, 0x63, 0x00},   // U+0025 (%)
    { 0x1C, 0x36, 0x1C, 0x6E, 0x3B, 0x33, 0x6E, 0x00},   // U+0026 (&)
    { 0x06, 0x06, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+0027 (')
    { 0x18, 0x0C, 0x06, 0x06, 0x06, 0x0C, 0x18, 0x00},   // U+0028 (()
    { 0x06, 0x0C, 0x18, 0x18, 0x18, 0x0C, 0x06, 0x00},   // U+0029 ())
    { 0x00, 0x66, 0x3C, 0xFF, 0x3C, 0x66, 0x00, 0x00},   // U+002A (*)
    { 0x00, 0x0C, 0x0C, 0x3F, 0x0C, 0x0C, 0x00, 0x00},   // U+002B (+)
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x0C, 0x0C, 0x06},   // U+002C (,)
    { 0x00, 0x00, 0x00, 0x3F, 0x00, 0x00, 0x00, 0x00},   // U+002D (-)
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x0C, 0x0C, 0x00},   // U+002E (.)
    { 0x60, 0x30, 0x18, 0x0C, 0x06, 0x03, 0x01, 0x00},   // U+002F (/)
    { 0x3E, 0x63, 0x73, 0x7B, 0x6F, 0x67, 0x3E, 0x00},   // U+0030 (0)
    { 0x0C, 0x0E, 0x0C, 0x0C, 0x0C, 0x0C, 0x3F, 0x00},   // U+0031 (1)
    { 0x1E, 0x33, 0x30, 0x1C, 0x06, 0x33, 0x3F, 0x00},   // U+0032 (2)
    { 0x1E, 0x33, 0x30, 0x1C, 0x30, 0x33, 0x1E, 0x00},   // U+0033 (3)
    { 0x38, 0x3C, 0x36, 0x33, 0x7F, 0x30, 0x78, 0x00},   // U+0034 (4)
    { 0x3F, 0x03, 0x1F, 0x30, 0x30, 0x33, 0x1E, 0x00},   // U+0035 (5)
    { 0x1C, 0x06, 0x03, 0x1F, 0x33, 0x33, 0x1E, 0x00},   // U+0036 (6)
    { 0x3F, 0x33, 0x30, 0x18, 0x0C, 0x0C, 0x0C, 0x00},   // U+0037 (7)
    { 0x1E, 0x33, 0x33, 0x1E, 0x33, 0x33, 0x1E, 0x00},   // U+0038 (8)
    { 0x1E, 0x33, 0x33, 0x3E, 0x30, 0x18, 0x0E, 0x00},   // U+0039 (9)
    { 0x00, 0x0C, 0x0C, 0x00, 0x00, 0x0C, 0x0C, 0x00},   // U+003A (:)
    { 0x00, 0x0C, 0x0C, 0x00, 0x00, 0x0C, 0x0C, 0x06},   // U+003B (//)
    { 0x18, 0x0C, 0x06, 0x03, 0x06, 0x0C, 0x18, 0x00},   // U+003C (<)
    { 0x00, 0x00, 0x3F, 0x00, 0x00, 0x3F, 0x00, 0x00},   // U+003D (=)
    { 0x06, 0x0C, 0x18, 0x30, 0x18, 0x0C, 0x06, 0x00},   // U+003E (>)
    { 0x1E, 0x33, 0x30, 0x18, 0x0C, 0x00, 0x0C, 0x00},   // U+003F (?)
    { 0x3E, 0x63, 0x7B, 0x7B, 0x7B, 0x03, 0x1E, 0x00},   // U+0040 (@)
    { 0x0C, 0x1E, 0x33, 0x33, 0x3F, 0x33, 0x33, 0x00},   // U+0041 (A)
    { 0x3F, 0x66, 0x66, 0x3E, 0x66, 0x66, 0x3F, 0x00},   // U+0042 (B)
    { 0x3C, 0x66, 0x03, 0x03, 0x03, 0x66, 0x3C, 0x00},   // U+0043 (C)
    { 0x1F, 0x36, 0x66, 0x66, 0x66, 0x36, 0x1F, 0x00},   // U+0044 (D)
    { 0x7F, 0x46, 0x16, 0x1E, 0x16, 0x46, 0x7F, 0x00},   // U+0045 (E)
    { 0x7F, 0x46, 0x16, 0x1E, 0x16, 0x06, 0x0F, 0x00},   // U+0046 (F)
    { 0x3C, 0x66, 0x03, 0x03, 0x73, 0x66, 0x7C, 0x00},   // U+0047 (G)
    { 0x33, 0x33, 0x33, 0x3F, 0x33, 0x33, 0x33, 0x00},   // U+0048 (H)
    { 0x1E, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x1E, 0x00},   // U+0049 (I)
    { 0x78, 0x30, 0x30, 0x30, 0x33, 0x33, 0x1E, 0x00},   // U+004A (J)
    { 0x67, 0x66, 0x36, 0x1E, 0x36, 0x66, 0x67, 0x00},   // U+004B (K)
    { 0x0F, 0x06, 0x06, 0x06, 0x46, 0x66, 0x7F, 0x00},   // U+004C (L)
    { 0x63, 0x77, 0x7F, 0x7F, 0x6B, 0x63, 0x63, 0x00},   // U+004D (M)
    { 0x63, 0x67, 0x6F, 0x7B, 0x73, 0x63, 0x63, 0x00},   // U+004E (N)
    { 0x1C, 0x36, 0x63, 0x63, 0x63, 0x36, 0x1C, 0x00},   // U+004F (O)
    { 0x3F, 0x66, 0x66, 0x3E, 0x06, 0x06, 0x0F, 0x00},   // U+0050 (P)
    { 0x1E, 0x33, 0x33, 0x33, 0x3B, 0x1E, 0x38, 0x00},   // U+0051 (Q)
    { 0x3F, 0x66, 0x66, 0x3E, 0x36, 0x66, 0x67, 0x00},   // U+0052 (R)
    { 0x1E, 0x33, 0x07, 0x0E, 0x38, 0x33, 0x1E, 0x00},   // U+0053 (S)
    { 0x3F, 0x2D, 0x0C, 0x0C, 0x0C, 0x0C, 0x1E, 0x00},   // U+0054 (T)
    { 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x3F, 0x00},   // U+0055 (U)
    { 0x33, 0x33, 0x33, 0x33, 0x33, 0x1E, 0x0C, 0x00},   // U+0056 (V)
    { 0x63, 0x63, 0x63, 0x6B, 0x7F, 0x77, 0x63, 0x00},   // U+0057 (W)
    { 0x63, 0x63, 0x36, 0x1C, 0x1C, 0x36, 0x63, 0x00},   // U+0058 (X)
    { 0x33, 0x33, 0x33, 0x1E, 0x0C, 0x0C, 0x1E, 0x00},   // U+0059 (Y)
    { 0x7F, 0x63, 0x31, 0x18, 0x4C, 0x66, 0x7F, 0x00},   // U+005A (Z)
    { 0x1E, 0x06, 0x06, 0x06, 0x06, 0x06, 0x1E, 0x00},   // U+005B ([)
    { 0x03, 0x06, 0x0C, 0x18, 0x30, 0x60, 0x40, 0x00},   // U+005C (\)
    { 0x1E, 0x18, 0x18, 0x18, 0x18, 0x18, 0x1E, 0x00},   // U+005D (])
    { 0x08, 0x1C, 0x36, 0x63, 0x00, 0x00, 0x00, 0x00},   // U+005E (^)
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF},   // U+005F (_)
    { 0x0C, 0x0C, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+0060 (`)
    { 0x00, 0x00, 0x1E, 0x30, 0x3E, 0x33, 0x6E, 0x00},   // U+0061 (a)
    { 0x07, 0x06, 0x06, 0x3E, 0x66, 0x66, 0x3B, 0x00},   // U+0062 (b)
    { 0x00, 0x00, 0x1E, 0x33, 0x03, 0x33, 0x1E, 0x00},   // U+0063 (c)
    { 0x38, 0x30, 0x30, 0x3e, 0x33, 0x33, 0x6E, 0x00},   // U+0064 (d)
    { 0x00, 0x00, 0x1E, 0x33, 0x3f, 0x03, 0x1E, 0x00},   // U+0065 (e)
    { 0x1C, 0x36, 0x06, 0x0f, 0x06, 0x06, 0x0F, 0x00},   // U+0066 (f)
    { 0x00, 0x00, 0x6E, 0x33, 0x33, 0x3E, 0x30, 0x1F},   // U+0067 (g)
    { 0x07, 0x06, 0x36, 0x6E, 0x66, 0x66, 0x67, 0x00},   // U+0068 (h)
    { 0x0C, 0x00, 0x0E, 0x0C, 0x0C, 0x0C, 0x1E, 0x00},   // U+0069 (i)
    { 0x30, 0x00, 0x30, 0x30, 0x30, 0x33, 0x33, 0x1E},   // U+006A (j)
    { 0x07, 0x06, 0x66, 0x36, 0x1E, 0x36, 0x67, 0x00},   // U+006B (k)
    { 0x0E, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x1E, 0x00},   // U+006C (l)
    { 0x00, 0x00, 0x33, 0x7F, 0x7F, 0x6B, 0x63, 0x00},   // U+006D (m)
    { 0x00, 0x00, 0x1F, 0x33, 0x33, 0x33, 0x33, 0x00},   // U+006E (n)
    { 0x00, 0x00, 0x1E, 0x33, 0x33, 0x33, 0x1E, 0x00},   // U+006F (o)
    { 0x00, 0x00, 0x3B, 0x66, 0x66, 0x3E, 0x06, 0x0F},   // U+0070 (p)
    { 0x00, 0x00, 0x6E, 0x33, 0x33, 0x3E, 0x30, 0x78},   // U+0071 (q)
    { 0x00, 0x00, 0x3B, 0x6E, 0x66, 0x06, 0x0F, 0x00},   // U+0072 (r)
    { 0x00, 0x00, 0x3E, 0x03, 0x1E, 0x30, 0x1F, 0x00},   // U+0073 (s)
    { 0x08, 0x0C, 0x3E, 0x0C, 0x0C, 0x2C, 0x18, 0x00},   // U+0074 (t)
    { 0x00, 0x00, 0x33, 0x33, 0x33, 0x33, 0x6E, 0x00},   // U+0075 (u)
    { 0x00, 0x00, 0x33, 0x33, 0x33, 0x1E, 0x0C, 0x00},   // U+0076 (v)
    { 0x00, 0x00, 0x63, 0x6B, 0x7F, 0x7F, 0x36, 0x00},   // U+0077 (w)
    { 0x00, 0x00, 0x63, 0x36, 0x1C, 0x36, 0x63, 0x00},   // U+0078 (x)
    { 0x00, 0x00, 0x33, 0x33, 0x33, 0x3E, 0x30, 0x1F},   // U+0079 (y)
    { 0x00, 0x00, 0x3F, 0x19, 0x0C, 0x26, 0x3F, 0x00},   // U+007A (z)
    { 0x38, 0x0C, 0x0C, 0x07, 0x0C, 0x0C, 0x38, 0x00},   // U+007B ({)
    { 0x18, 0x18, 0x18, 0x00, 0x18, 0x18, 0x18, 0x00},   // U+007C (|)
    { 0x07, 0x0C, 0x0C, 0x38, 0x0C, 0x0C, 0x07, 0x00},   // U+007D (})
    { 0x6E, 0x3B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+007E (~)
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+007F
    { 0xfe, 0xfc, 0xf8, 0xf0, 0xf0, 0xf8, 0xfc, 0xfe},   // U+0080 (powerline filled >)
};

unsigned int ww, wh, wx, wy;
int cfg, cbg;

#define TTY_HEIGHT (VGA_HEIGHT/8)
#define TTY_WIDTH (VGA_WIDTH/8)
int vt100_state = 0;
unsigned int cx, cy;
struct tcell {
  unsigned char c;
  unsigned int fgcolor, bgcolor;
  unsigned char mod;
} term[TTY_WIDTH][TTY_HEIGHT];

void init_vgatext(void) {
  printf("Term at %x to %x", term, term + sizeof(term));
  for(cx = 0; cx < TTY_WIDTH; cx++)
    for(cy = 0; cy < TTY_HEIGHT; cy++) {
      term[cx][cy].c = ' ';
      term[cx][cy].fgcolor = console_colors[14];
      term[cx][cy].bgcolor = console_colors[0];
      term[cx][cy].mod = 1;
    }
  ww = TTY_WIDTH;
  wh = TTY_HEIGHT - 1;
  wx = wy = 0;
  cx = cy = 0;
  cfg = console_colors[14];
  cbg = console_colors[0];
  vt100_state = 0;
}

void vga_addch(int x, int y, int c) {
  term[x][y].c = c;
  term[x][y].fgcolor = cfg;
  term[x][y].bgcolor = cbg;
  term[x][y].mod = 1;
}

void vga_set_color(int fg, int bg) {
  cfg = fg;
  cbg = bg;
}

void vga_clear_text() {
  for(cx = 0; cx < TTY_WIDTH; cx++)
    for(cy = 0; cy < TTY_HEIGHT; cy++) {
      term[cx][cy].c = ' ';
      term[cx][cy].fgcolor = cfg;
      term[cx][cy].bgcolor = cbg;
      term[cx][cy].mod = 1;
    }
  cx = cy = 0;
  vga_redraw();
}

void vga_setwin(int w, int h, int x, int y) {
  ww = w;
  wh = h;
  wx = x;
  wy = y;
}

void vga_redraw(void) {
  if((int) term > 0x1000000) printf("term = %x!", term);
  vga_update_curs();
  unsigned int x, y, tx, ty;
  for(x = 0; x < ww; x++) {
    for(y = 0; y < wh; y++) {
      if(term[x][y].mod) {
	for(ty = 0; ty < 8; ty++) {
	  for(tx = 0; tx < 8; tx++) {
	    vga_write_pix(
			  x * 8 + tx + wx,
			  y * 8 + ty + wy,
			  (font8x8_basic[(int) term[x][y].c][ty] & (1 << tx)) ? term[x][y].fgcolor : term[x][y].bgcolor);
	  }
	}
	term[x][y].mod = 0;
      }
    }
  }
}

void vga_statchar(int c, int x) {
  int ty, tx;
  for(ty = 0; ty < 8; ty++) {
    for(tx = 0; tx < 8; tx++) {
      vga_write_pix(
		    x * 8 + tx,
		    ty + (VGA_HEIGHT - 8),
		    (font8x8_basic[c][ty] & (1 << tx)) ? 0x00FF00 : 0x000000);
    }
  }
}

void vga_scroll() {
  unsigned int x, y, tx, ty;
  for(x = 0; x < ww; x++) {
    for(y = 0; y < (wh - 1); y++) {
      if(term[x][y].c != term[x][y+1].c)
	for(tx = 0; tx < 8; tx++) {
	  for(ty = 0; ty < 8; ty++) {
	    vga_write_pix(
			  x * 8 + tx + wx,
			  y * 8 + ty + wy,
			  (font8x8_basic[(int) term[x][y + 1].c][ty] & (1 << tx)) ? term[x][y + 1].fgcolor : term[x][y + 1].bgcolor);
	    
	  }
	}
      term[x][y].c = term[x][y+1].c;
      term[x][y].fgcolor = term[x][y+1].fgcolor;
      term[x][y].bgcolor = term[x][y+1].bgcolor;
      term[x][y].mod = 0;
    }
  }
  y = wh - 1;
  for(x = 0; x < ww; x++) {
    for(tx = 0; tx < 8; tx++) {
      for(ty = 0; ty < 8; ty++) {
	vga_write_pix(
		      x * 8 + tx + wx,
		      y * 8 + ty + wy,
		      term[x][y].bgcolor);
	
      }
    }
  }
}

volatile int cs;

void vga_update_curs() {
  if(cs) {
    term[cx][cy].c = '_';
  } else {
    term[cx][cy].c = ' ';
  }
  term[cx][cy].mod = 1;
}

void vga_writechar(int c) {
  switch(c) {
  case '\n':
    for(; cx < ww; cx++) {
      term[cx][cy].c = ' ';
      term[cx][cy].mod = 1;
    }
    cx = 0;
    cy++;
    vga_redraw();
    break;
  case '\b':
    cx--;
    if(cx == (unsigned int) -1) cx = 0;
    else {
      term[cx + 1][cy].c = ' ';
      term[cx + 1][cy].mod = 1;
    }
    break;
  default:
    term[cx][cy].mod = 1;
    term[cx][cy].c = c;
    term[cx][cy].fgcolor = cfg;
    term[cx++][cy].bgcolor = cbg;
    break;
  }
  if(cx > ww - 1) {
    cx = 0;
    cy++;
  }
  if(cy > wh - 1) {
    cy = wh - 1;
    vga_scroll();
  }
  outb(0x3f8, c);
  vga_update_curs();
}

int vt100_params[16];
int vt100_pi = 0;
struct vattrs {
  char bold;
} vt100_attr;

void vga_csi_dispatch(int c) {
  int i;
  switch(c) {
  case 'm':
    for(i = 0; i <= vt100_pi; i++) {
      if(vt100_params[i] == 0) {
	cfg = console_colors[14];
	cbg = console_colors[0];
	vt100_attr.bold = 0;
      } else if(vt100_params[i] == 1) {
	vt100_attr.bold = 1;
      } else if(vt100_params[i] < 40)
	cfg = console_colors[(vt100_params[i] - 30) + vt100_attr.bold * 8];
      else cbg = console_colors[vt100_params[i] - 40];
    }
    break;
  }
}

void vga_putchar(int c) {
  // TODO: PROPER UTF-8 SUPPORT! THIS IS A HACK
  c = (unsigned char) ((char) c);
  int vt100_desc = vt100[vt100_state][(unsigned int) c];
  int action = (vt100_desc & 0xF0) >> 4;
  int state = vt100_desc & 0x0F, i;
  switch(action) {
  case 1: // print
    vga_writechar(c);
    break;
  case 2: // execute
    vga_writechar(c);
    break;
  case 3: // clear
    vt100_pi = 0;
    break;
  case 4: // collect
    break;
  case 5: // param
    if(c == ';') vt100_pi++;
    else {
      vt100_params[vt100_pi] *= 10;
      vt100_params[vt100_pi] += c - '0';
    }
    break;
  case 6: // esc_dispatch
    break;
  case 7: // csi_dispatch
    vga_csi_dispatch(c);
    for(i = 0; i < 16; i++)
      vt100_params[i] = 0;
    vt100_pi = 0;
    break;
  default:
    break;
  }
  vt100_state = state;
}

void vga_puts(char *s) {
  while(*s) {
    vga_putchar(*s);
    s++;
  }
}

const char digits[] = "0123456789abcdef";

void vga_itoa_u(unsigned long i, unsigned int radix) {
  if(i >= radix)
    vga_itoa_u(i / radix, radix);
  vga_putchar(digits[i % radix]);
}

void vga_itoa_s(signed long i, int radix) {
  if(i < 0) {
    i = -i;
    vga_putchar('-');
  }
  vga_itoa_u((unsigned long) i, radix);
}

#define gc(f) (*((f)++))
#define ugc(f) --(f)

#define LEN_8  0
#define LEN_16 1
#define LEN_32 2
#define LEN_64 3


void printf(const char *fmt, ...) {
  __builtin_va_list ap;
  __builtin_va_start(ap, fmt);
  vprintf(fmt, ap);
  __builtin_va_end(ap);
}

void vprintf(const char *fmt, __builtin_va_list ap) {
  char c;
  int length = -1;
  while(*fmt) {
    if(*fmt == '%') {
      fmt++;
      switch(c = gc(fmt)) {
      case 'h':
	if((c = gc(fmt)) == 'h') {
	  length = LEN_8;
	} else {
	  length = LEN_16;
	  ugc(fmt);
	}
	break;
      case 'l':
	if((c = gc(fmt)) == 'l') {
	  length = LEN_64;
	} else {
	  length = LEN_32;
	  ugc(fmt);
	}
	break;
      case 'd':
      case 'i':
	switch(length) {
	case LEN_64:
	  vga_itoa_s(__builtin_va_arg(ap, signed long long), 10);
	  break;
	default:
	  vga_itoa_s(__builtin_va_arg(ap, signed int), 10);
	  break;
	}
	break;
      case 'u':
	switch(length) {
	case LEN_64:
	  vga_itoa_u(__builtin_va_arg(ap, unsigned long), 10);
	  break;
	default:
	  vga_itoa_u(__builtin_va_arg(ap, unsigned int), 10);
	  break;
	}
	break;
      case 'o':
	switch(length) {
	case LEN_64:
	  vga_itoa_u(__builtin_va_arg(ap, unsigned long), 8);
	  break;
	default:
	  vga_itoa_u(__builtin_va_arg(ap, unsigned int), 8);
	  break;
	}
	break;
      case 'x':
	switch(length) {
	case LEN_64:
	  vga_itoa_u(__builtin_va_arg(ap, unsigned long), 16);
	  break;
	default:
	  vga_itoa_u(__builtin_va_arg(ap, unsigned int), 16);
	  break;
	}
	break;
      case 'c':
	vga_putchar(__builtin_va_arg(ap, unsigned int));
	break;
      case 's':
	vga_puts(__builtin_va_arg(ap, char *));
	break;
      case '%':
	vga_putchar('%');
	break;
      }
    } else {
      vga_putchar(gc(fmt));
    }
  }
}
